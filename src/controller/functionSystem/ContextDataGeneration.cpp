#include "controller/functionSystem/ContextDataGeneration.h"
#include "controller/Controller.h"
#include "controller/IControlListener.h"
#include "controller/controls/ControlFunction.h"
#include "models/graph/SimpleMeasureNode.h"
#include "models/graph/TagNode.h"
#include "models/graph/PolylineMeasureNode.h"

#include "utils/Logger.h"
#include "utils/Utils.h"

ContextDataGeneration::ContextDataGeneration(const ContextId& id)
    : AContext(id)
{
    m_state = ContextState::ready_for_using;
}

ContextDataGeneration::~ContextDataGeneration()
{
}

ContextState ContextDataGeneration::start(Controller& controller)
{
    return m_state;
}

ContextState ContextDataGeneration::feedMessage(IMessage* message, Controller& controller)
{
    return m_state;
}

ContextState ContextDataGeneration::launch(Controller& controller)
{
    FUNCLOG << "ContextDataGeneration launch" << LOGENDL;
    std::unordered_set<SafePtr<AGraphNode>> new_nodes;

    generateTags(controller, new_nodes);

    //generateSimpleMeasures(controller, new_nodes);

    //generatePolyMeasures(controller, new_nodes);

    controller.getControlListener()->notifyUIControl(new control::function::AddNodes(new_nodes));
    return (m_state = ContextState::done);
}

bool ContextDataGeneration::canAutoRelaunch() const
{
    return (false);
}

ContextType ContextDataGeneration::getType() const
{
    return (ContextType::autoGenerateData);
}

void ContextDataGeneration::generateTags(Controller& controller, std::unordered_set<SafePtr<AGraphNode>>& ret_nodes)
{
    // Crée 10000 tags répartis sur une grille (X, Y)
    const glm::dvec3 min_pos(-50.0, -50.0, 0.0);
    const glm::dvec3 max_pos(50.0, 50.0, 40.0);
    const size_t step_X = 20;
    const size_t step_Y = 20;
    const glm::dvec3 pos_range = max_pos - min_pos;
    for (int x = 0; x < step_X; ++x)
    {
        for (int y = 0; y < step_Y; ++y)
        {
            SafePtr<TagNode> tag = make_safe<TagNode>();
            {
                WritePtr<TagNode> wTag = tag.get();
                if (!wTag)
                    continue;

                wTag->setDefaultData(controller);

                double dx = (double)x / step_X;
                double dy = (double)y / step_Y;
                double dz = (1.0 + cos(dx * 3.1415) * sin(dy * 3.1415)) / 2.0;
                glm::dvec3 pos(min_pos.x + dx * pos_range.x,
                    min_pos.y + dy * pos_range.y,
                    min_pos.z + dz * pos_range.z);
                wTag->setPosition(pos);

                glm::vec3 rgb(dx, dy, 1.f - dx * dy);
                wTag->setColor(Color32(rgb));
                int random_icon = std::rand() % (int)scs::MarkerIcon::Max_Enum;
                wTag->setMarkerIcon((scs::MarkerIcon)random_icon);
                time_t timeNow;
                wTag->setCreationTime(time(&timeNow));
            }
            ret_nodes.insert(tag);
        }
    }
}
void ContextDataGeneration::generateSimpleMeasures(Controller& controller, std::unordered_set<SafePtr<AGraphNode>>& ret_nodes)
{
    // Crée 200 SimpleMeasure
    for (int i = 0; i < 200; ++i)
    {
        double i_x = i % 100 * 1.0;
        double i_y = i / 100 * 10.0;
        glm::dvec3 start(i_x, i_y, 0.0);
        glm::dvec3 end = start + glm::dvec3(0.0, 5.0, i * 0.025);

        SafePtr<SimpleMeasureNode> measure = make_safe<SimpleMeasureNode>();
        {
            WritePtr<SimpleMeasureNode> wMeasure = measure.get();
            if (!wMeasure)
                continue;

            wMeasure->setDefaultData(controller);
            wMeasure->setCreationTime(time(nullptr));
            wMeasure->setOriginPos(start);
            wMeasure->setDestinationPos(end);
        }
        ret_nodes.insert(measure);
    }

}
void ContextDataGeneration::generatePolyMeasures(Controller& controller, std::unordered_set<SafePtr<AGraphNode>>& ret_nodes)
{
    // 800 PolylineMeasure (200 2sg, 200 3sg, 200 4sg, 200 5sg)
    for (int i = 0; i < 800; ++i)
    {
        int segmentCount = 2 + (i / 200); // 2, 3, 4 or 5 segments
        double i_x = i % 100 * 1.0;
        double i_y = (i % 200) / 100 * 10.0;

        SafePtr<PolylineMeasureNode> measure = make_safe<PolylineMeasureNode>();
        {
            WritePtr<PolylineMeasureNode> wMeasure = measure.get();
            if (!wMeasure)
                continue;

            wMeasure->setDefaultData(controller);
            wMeasure->setCreationTime(time(nullptr));
            for (int j = 0; j < segmentCount; ++j)
            {
                glm::dvec3 P1(i_x + (j % 2) * 1.0, i_y + j * 1.0, segmentCount * 5.0);
                // On étend en zigzag
                glm::dvec3 P2 = P1 + glm::dvec3((1.0 - (j % 2) * 2.0), 1.0, 0.0);
                Measure m = { P1, P2 };
                wMeasure->addMeasure(m);
            }
        }
        ret_nodes.insert(measure);
    }
}

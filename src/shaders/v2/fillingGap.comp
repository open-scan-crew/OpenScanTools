#version 450

layout (local_size_x = 16, local_size_y = 16) in;

layout(set = 0, binding = 0, rgba8) uniform image2D inOutColorImage;
layout(set = 0, binding = 1) uniform sampler2D rawDepthImage;
layout(set = 1, binding = 2) buffer correctedDepth
{
    float depth[ ];
};

layout(push_constant) uniform PC {
   layout(offset = 0) vec2 nearFar;
   layout(offset = 8) ivec2 screenSize;
   layout(offset = 16) float pxSize;
   layout(offset = 20) int projMode;
   layout(offset = 56) int texelThreshold;
   layout(offset = 60) int gapFillingExpert;
   layout(offset = 64) int gapFillingNearThreshold;
   layout(offset = 68) int gapFillingFarThreshold;
   layout(offset = 72) float gapFillingNearStart;
   layout(offset = 76) float gapFillingNearEnd;
   layout(offset = 80) float gapFillingFarStart;
   layout(offset = 84) float gapFillingFarEnd;
   layout(offset = 88) int gapFillingCurveType;
   layout(offset = 92) float gapFillingCurveBias;
} pc;

void fillIn(in vec4[9] color, in float[9] depth, in int texelThreshold, out vec4 newColor, out float newDepth)
{
   // Methode A : AVEC boucle for
   //float nearest = depth[1];
   //for (int i = 2; i < 9; ++i)
   //   nearest = min(nearest, depth[i]);
   
   int validTexelCount = 0;
            validTexelCount++;
   float threshold = float(texelThreshold);
   if (pc.gapFillingExpert != 0)
      float depthClamped = clamp(depth[0], pc.gapFillingNearStart, pc.gapFillingFarEnd);
      if (depthClamped <= pc.gapFillingNearEnd)
         threshold = float(pc.gapFillingNearThreshold);
      else if (depthClamped >= pc.gapFillingFarStart)
         threshold = float(pc.gapFillingFarThreshold);
      else
      {
         float blendRange = max(pc.gapFillingFarStart - pc.gapFillingNearEnd, 0.0001);
         float t = clamp((depthClamped - pc.gapFillingNearEnd) / blendRange, 0.0, 1.0);
         if (pc.gapFillingCurveType == 1)
         {
            t = t * t * (3.0 - 2.0 * t);
         }
         else if (pc.gapFillingCurveType == 2)
         {
            t = pow(t, max(pc.gapFillingCurveBias, 0.0001));
         }
         threshold = mix(float(pc.gapFillingNearThreshold), float(pc.gapFillingFarThreshold), t);
      }
   }
   if (float(validTexelCount) >= threshold)
   {
      newColor = cumulColor / validTexelCount;
      newDepth = cumulDepth / validTexelCount;
   //   * RenderDoc donne des temps d'execution parfaitement similaires
   //   * Le shader pÃ¨se 300 octets de plus avec B.
   //   * La methode B est plus souple pour l'organisation interne des pixels

   int validTexel = 0;
   float deltaDepth = pc.projMode == 0 ? pc.pxSize * nearest * 8.0 : pc.pxSize * 8.0;
   vec4 cumulColor = vec4(0.0, 0.0, 0.0, 0.0);
   float cumulDepth = 0.0;
   if (depth[0] > nearest + deltaDepth)
   {
      for (int i = 1; i < 9; ++i)
      {
         if (depth[i] < nearest + deltaDepth)
         {
            validTexel++;
            cumulColor += color[i];
            cumulDepth += depth[i];
         }
      }
   }

   if (validTexel >= texelThreshold)
   {
      newColor = cumulColor / validTexel;
      newDepth = cumulDepth / validTexel;
   }
   else
   {
      newColor = color[0];
      newDepth = depth[0];
   }
}

int bindingIJ[9] = {
   5, 1, 6,
   2, 0, 3,
   7, 4, 8
};

struct ImageData 
{
   vec4 color[9];
   float depth[9];
} imageData;

void main() 
{
   if (gl_GlobalInvocationID.x >= pc.screenSize.x ||
       gl_GlobalInvocationID.y >= pc.screenSize.y)
      return;

   float diffFarNear = pc.nearFar.y - pc.nearFar.x;
   float mulFarNear = pc.nearFar.y * pc.nearFar.x;

   int n = -1;
   for (int i = -1; i < 2; ++i)
   {
      for (int j = -1; j < 2; ++j)
      {
         ++n;
         int m = bindingIJ[n];
         ivec2 iUV = ivec2(gl_GlobalInvocationID.x + i, gl_GlobalInvocationID.y + j);
         imageData.color[m] = imageLoad(inOutColorImage, iUV);
         float rawDepth = texture(rawDepthImage, iUV).r;
         if (pc.projMode == 0)
            // Perspective
            imageData.depth[m] = mulFarNear / (pc.nearFar.y - diffFarNear * rawDepth);
         else
            // Orthographic
            imageData.depth[m] = rawDepth * diffFarNear + pc.nearFar.x;
      }
   }

   // Calcule la couleur et la profondeur par extrapolation des pixels voisins
   vec4 newC;
   float newZ;
   fillIn(imageData.color, imageData.depth, pc.texelThreshold, newC, newZ);
   float newD = pc.projMode == 0 ?
                (pc.nearFar.y - mulFarNear / newZ) / diffFarNear :
                (newZ - pc.nearFar.x) / diffFarNear;

   imageStore(inOutColorImage, ivec2(gl_GlobalInvocationID.xy), newC);
   uint index = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * pc.screenSize.x;
   depth[index] = newD;
}

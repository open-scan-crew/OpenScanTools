#version 450

// Screen-space ambient occlusion for point clouds.
// Depth convention: correctedDepth.depth[] stores a float per pixel, depth > 0 is valid,
// 0 (or <= 0) means no geometry. Depth increases with distance from the camera.
// We work in log depth space to remain stable on large ranges.

layout (local_size_x = 16, local_size_y = 16) in;

layout(set = 0, binding = 0, r16f) uniform image2D aoImage;
layout(set = 1, binding = 2) buffer correctedDepth
{
    float depth[];
};

layout(push_constant) uniform PC {
   layout(offset = 0) ivec2 screenSize;
   layout(offset = 8) float radius;       // Base radius in pixels
   layout(offset = 12) float depthReject; // Relative log-depth guard
   layout(offset = 16) float bias;        // Small bias to avoid self-occlusion
} pc;

const int KERNEL_SIZE = 16;
const vec3 kernel[KERNEL_SIZE] = vec3[](
    vec3(0.5381, 0.1856, 0.4319),
    vec3(0.1379, 0.2486, 0.4430),
    vec3(0.3371, 0.5679, 0.0057),
    vec3(0.7250, 0.0451, 0.0973),
    vec3(0.2455, 0.4175, 0.3360),
    vec3(0.3135, 0.0424, 0.9935),
    vec3(0.7015, 0.3549, 0.2546),
    vec3(0.1564, 0.4899, 0.6610),
    vec3(0.2231, 0.6999, 0.5196),
    vec3(0.1735, 0.4565, 0.8723),
    vec3(0.3475, 0.2320, 0.7319),
    vec3(0.0020, 0.9546, 0.2183),
    vec3(0.4034, 0.7008, 0.2851),
    vec3(0.0295, 0.8273, 0.6097),
    vec3(0.5224, 0.6915, 0.0439),
    vec3(0.7731, 0.3281, 0.5912)
);

float fetchDepth(ivec2 coord)
{
    ivec2 clamped = clamp(coord, ivec2(0), pc.screenSize - ivec2(1));
    uint idx = uint(clamped.x + clamped.y * pc.screenSize.x);
    return depth[idx];
}

float hash12(uvec2 p)
{
    uint n = p.x * 0x1f123bb5u + p.y * 0x59c3af2du;
    n = (n ^ (n >> 16u)) * 0x27d4eb2du;
    n ^= (n >> 15u);
    return float(n & 0x00FFFFFFu) / float(0x01000000u);
}

vec3 computeNormal(ivec2 gid, float centerDepth)
{
    float left = fetchDepth(gid + ivec2(-1, 0));
    float right = fetchDepth(gid + ivec2(1, 0));
    float up = fetchDepth(gid + ivec2(0, -1));
    float down = fetchDepth(gid + ivec2(0, 1));

    left = (left <= 0.0) ? centerDepth : left;
    right = (right <= 0.0) ? centerDepth : right;
    up = (up <= 0.0) ? centerDepth : up;
    down = (down <= 0.0) ? centerDepth : down;

    float logL = log2(max(left, 1e-6) + 1.0);
    float logR = log2(max(right, 1e-6) + 1.0);
    float logU = log2(max(up, 1e-6) + 1.0);
    float logD = log2(max(down, 1e-6) + 1.0);

    vec3 n = normalize(vec3(-(logR - logL), -(logD - logU), 2.2));
    if (any(isnan(n)) || any(isinf(n)))
        n = vec3(0.0, 0.0, 1.0);
    return n;
}

void main()
{
    ivec2 gid = ivec2(gl_GlobalInvocationID.xy);
    if (gid.x >= pc.screenSize.x || gid.y >= pc.screenSize.y)
        return;

    const uint idx = uint(gid.x + gid.y * pc.screenSize.x);
    const float centerDepth = depth[idx];
    if (centerDepth <= 0.0)
    {
        imageStore(aoImage, gid, vec4(1.0, 0.0, 0.0, 1.0));
        return;
    }

    const float centerLog = log2(max(centerDepth, 1e-6) + 1.0);
    const float radiusPx = pc.radius * mix(0.9, 1.3, clamp(centerDepth * 0.02, 0.0, 1.0));
    const float angle = hash12(uvec2(gid)) * 6.2831853;
    const vec2 noise = vec2(cos(angle), sin(angle));
    const mat2 rot = mat2(noise.x, -noise.y, noise.y, noise.x);
    const vec3 normal = computeNormal(gid, centerDepth);

    float occAccum = 0.0;
    float sampleCount = 0.0;

    for (int i = 0; i < KERNEL_SIZE; ++i)
    {
        vec2 dir = rot * normalize(kernel[i].xy * 2.0 - 1.0);
        float stepLen = (0.45 + 0.65 * kernel[i].z) * radiusPx;
        ivec2 sampleCoord = gid + ivec2(round(dir * stepLen));

        float sampleDepth = fetchDepth(sampleCoord);
        if (sampleDepth <= 0.0)
            continue;

        float logSample = log2(max(sampleDepth, 1e-6) + 1.0);
        float logDelta = centerLog - logSample - pc.bias;
        if (logDelta <= 0.0)
            continue;

        float guard = pc.depthReject * max(centerLog, logSample) + pc.bias;
        float normDelta = clamp(logDelta / max(guard, 1e-4), 0.0, 1.0);

        // Directional term biases occlusion towards samples aligned with the local normal
        float dirWeight = clamp(dot(normal, normalize(vec3(dir, 0.85))), 0.0, 1.0);
        float occlusion = pow(normDelta, 0.6) * dirWeight;
        occAccum += occlusion;
        sampleCount += 1.0;
    }

    float ao = 1.0 - (sampleCount > 0.0 ? occAccum / sampleCount : 0.0);
    ao = clamp(ao, 0.0, 1.0);
    imageStore(aoImage, gid, vec4(ao, 0.0, 0.0, 1.0));
}

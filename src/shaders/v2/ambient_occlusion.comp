#version 450

layout (local_size_x = 16, local_size_y = 16) in;

layout(set = 0, binding = 0, rgba8) uniform image2D inOutColorImage;
layout(set = 1, binding = 2) buffer correctedDepth
{
    float inDepth[ ];
};

layout(push_constant) uniform PC {
    layout(offset = 0) ivec2 screenSize;
    layout(offset = 8) vec2 nearFar;
    layout(offset = 16) float radius;
    layout(offset = 20) float intensity;
    layout(offset = 24) int projMode;
} pc;

const float PI = 3.14159265359;

float linearizeDepth(float rawDepth)
{
    float diffFarNear = pc.nearFar.y - pc.nearFar.x;
    float mulFarNear = pc.nearFar.y * pc.nearFar.x;
    if (pc.projMode == 0)
        return mulFarNear / (pc.nearFar.y - rawDepth * diffFarNear);
    return rawDepth * diffFarNear + pc.nearFar.x;
}

float rand01(vec2 co)
{
    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
}

vec2 rotateVec2(vec2 v, float angle)
{
    float s = sin(angle);
    float c = cos(angle);
    return vec2(c * v.x - s * v.y, s * v.x + c * v.y);
}

void main()
{
    ivec2 gid = ivec2(gl_GlobalInvocationID.xy);
    if (gid.x >= pc.screenSize.x || gid.y >= pc.screenSize.y)
        return;

    vec4 imageColor = imageLoad(inOutColorImage, gid);
    if (imageColor.a == 0.0 || pc.intensity <= 0.0 || pc.radius <= 0.0)
        return;

    uint index = uint(gid.x + gid.y * pc.screenSize.x);
    float centerDepth = linearizeDepth(inDepth[index]);

    const int sampleCount = 12;
    vec2 samples[sampleCount] = vec2[](
        vec2(1.0, 0.0), vec2(-1.0, 0.0),
        vec2(0.0, 1.0), vec2(0.0, -1.0),
        vec2(0.7071, 0.7071), vec2(-0.7071, 0.7071),
        vec2(0.7071, -0.7071), vec2(-0.7071, -0.7071),
        vec2(0.9239, 0.3827), vec2(-0.9239, 0.3827),
        vec2(0.3827, 0.9239), vec2(-0.3827, 0.9239)
    );

    float angle = rand01(vec2(gid)) * (2.0 * PI);
    float occlusion = 0.0;
    float bias = max(0.0005, centerDepth * 0.0015);
    float depthRange = max(0.001, centerDepth * 0.05);

    for (int i = 0; i < sampleCount; ++i)
    {
        float scale = 0.3 + 0.7 * (float(i + 1) / float(sampleCount));
        vec2 offset = rotateVec2(samples[i], angle) * pc.radius * scale;
        ivec2 samplePos = gid + ivec2(round(offset));
        if (samplePos.x < 0 || samplePos.y < 0 || samplePos.x >= pc.screenSize.x || samplePos.y >= pc.screenSize.y)
            continue;

        uint sIndex = uint(samplePos.x + samplePos.y * pc.screenSize.x);
        float sampleDepth = linearizeDepth(inDepth[sIndex]);
        float depthDelta = centerDepth - sampleDepth;
        if (depthDelta > bias)
        {
            float rangeWeight = clamp(1.0 - (depthDelta / depthRange), 0.0, 1.0);
            occlusion += rangeWeight;
        }
    }

    float ao = 1.0 - (occlusion / float(sampleCount));
    float factor = mix(1.0, ao, clamp(pc.intensity, 0.0, 1.0));
    imageStore(inOutColorImage, gid, vec4(imageColor.rgb * factor, imageColor.a));
}

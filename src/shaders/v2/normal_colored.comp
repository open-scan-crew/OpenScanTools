#version 450
#extension GL_GOOGLE_include_directive : enable

layout (local_size_x = 16, local_size_y = 16) in;

layout(set = 0, binding = 0, rgba8) uniform image2D inOutColorImage;
layout(set = 1, binding = 2) buffer correctedDepth
{
    float inDepth[ ];
};

layout(set = 2, binding = 4) uniform uniformCamera {
    mat4 inversedView;
} uCam;

layout(push_constant) uniform PC {
   layout(offset = 0) vec2 nearFar;
   layout(offset = 8) ivec2 screenSize;
   layout(offset = 16) vec2 screenOffset;
   layout(offset = 24) vec2 pxSize;
   layout(offset = 32) int projMode;
   layout(offset = 36) int inverseTone;
   layout(offset = 40) float ka;
   layout(offset = 48) float diffuse_pow;
   layout(offset = 52) int blendColor;
   layout(offset = 56) float aoRadius;
   layout(offset = 60) float aoIntensity;
   layout(offset = 64) int aoEnabled;
   layout(offset = 68) int aoUseTopLight;
   layout(offset = 72) float aoTopLightStrength;
   layout(offset = 76) int normalsEnabled;
} pc;


#include "./normal_functions.glsl"

vec4 imageColor;
float imageDepth[9];

float depthToLinear(float rawDepth, float diffFarNear, float mulFarNear)
{
   if (pc.projMode == 0)
      return mulFarNear / (pc.nearFar.y - rawDepth * diffFarNear);
   return rawDepth * diffFarNear + pc.nearFar.x;
}

void main() 
{
   if (gl_GlobalInvocationID.x - 1 >= pc.screenSize.x - 2 ||
       gl_GlobalInvocationID.y - 1 >= pc.screenSize.y - 2)
      return;

   imageColor = imageLoad(inOutColorImage, ivec2(gl_GlobalInvocationID.xy));
   if (imageColor.a == 0)
      return;

   float diffFarNear = pc.nearFar.y - pc.nearFar.x;
   float mulFarNear = pc.nearFar.y * pc.nearFar.x;

   int n = -1;
   for (int i = -1; i < 2; ++i)
   {
      for (int j = -1; j < 2; ++j)
      {
         ++n;
         uint index = gl_GlobalInvocationID.x + i + (gl_GlobalInvocationID.y + j) * pc.screenSize.x;
         imageDepth[n] = depthToLinear(inDepth[index], diffFarNear, mulFarNear);
      }
   }

   // Calcule la normale
   vec3 normal = pc.projMode == 0 ? computeNormal_perspective(imageDepth) : computeNormal_ortho(imageDepth);
   vec4 gn = uCam.inversedView * vec4(normal, 0.0);

   vec3 shadedColor = imageColor.rgb;
   if (pc.normalsEnabled != 0)
   {
      float strength = clamp(pc.ka, 0.0, 1.0);
      shadedColor = mix(abs(gn).xyz, imageColor.rgb, strength);
   }

   float aoFactor = 1.0;
   float aoVis = 0.0;
   if (pc.aoEnabled != 0 && pc.aoIntensity > 0.0)
   {
      float centerDepth = imageDepth[4];
      if (centerDepth > 0.0 && centerDepth < pc.nearFar.y - 1.0)
      {
         const vec2 kernel[12] = vec2[12](
            vec2(1, 0), vec2(-1, 0), vec2(0, 1), vec2(0, -1),
            vec2(1, 1), vec2(-1, 1), vec2(1, -1), vec2(-1, -1),
            vec2(2, 0), vec2(-2, 0), vec2(0, 2), vec2(0, -2));

         float radiusPx = 2.0 + pc.aoRadius * 18.0;
         float bias = max(centerDepth * 0.0005, 0.0002);
         float occ = 0.0;
         float weightSum = 0.0;

         for (int k = 0; k < 12; ++k)
         {
            vec2 dir = kernel[k];
            float lenDir = length(dir);
            float scaled = radiusPx / max(lenDir, 1.0);
            ivec2 offset = ivec2(round(dir * scaled));
            ivec2 sampleCoord = clamp(ivec2(gl_GlobalInvocationID.xy) + offset, ivec2(1), pc.screenSize - ivec2(2));
            uint sampleIndex = uint(sampleCoord.x + sampleCoord.y * pc.screenSize.x);
            float rawDepth = inDepth[sampleIndex];
            if (rawDepth <= 0.0f)
               continue;

            float sampleDepth = depthToLinear(rawDepth, diffFarNear, mulFarNear);
            float delta = centerDepth - sampleDepth - bias;
            float dirWeight = 1.0 / (1.0 + lenDir);
            float falloff = 1.0 - clamp(length(vec2(offset)) / (radiusPx + 1e-3), 0.0, 1.0);

            if (delta > 0.0)
            {
               float range = delta / (centerDepth + bias);
               float occlusion = clamp(range * 5.0, 0.0, 1.0) * falloff;
               occ += occlusion * dirWeight;
            }
            weightSum += dirWeight;
         }

         if (weightSum > 0.0)
         {
            aoVis = clamp(occ / weightSum, 0.0, 1.0);
            aoVis = pow(aoVis, 0.3);
         }
      }
   }

   float topLight = 1.0;
   if (pc.aoUseTopLight != 0 && pc.aoEnabled != 0)
   {
      float normLen = length(normal);
      if (normLen > 1e-4)
      {
         vec3 n = normal / normLen;
         float nz = clamp(n.z * 0.75 + 0.5, 0.0, 1.0);
         topLight = mix(1.0, nz, clamp(pc.aoTopLightStrength, 0.0, 1.0));
      }
   }

   float shadowWeight = 1.0;
   float normLen = length(normal);
   if (normLen > 1e-4)
   {
      vec3 n = normal / normLen;
      shadowWeight = clamp(1.0 - max(n.z, 0.0), 0.0, 1.0);
   }
   float aoIntensityScaled = pow(max(pc.aoIntensity, 0.0), 1.3);
   float occlusionStrength = clamp(aoIntensityScaled * aoVis, 0.0, 1.4);
   aoFactor = 1.0 - occlusionStrength * shadowWeight;

   float ambientFloor = mix(0.9, 0.6, clamp(aoIntensityScaled * 0.6, 0.0, 1.0));
   float aoDark = max(aoFactor, ambientFloor);

   vec3 litColor = shadedColor * topLight;
   vec4 newC = vec4(litColor * mix(1.0, aoDark, shadowWeight), imageColor.a);
   imageStore(inOutColorImage, ivec2(gl_GlobalInvocationID.xy), newC);
}

#version 450

layout (local_size_x = 16, local_size_y = 16) in;

layout(set = 0, binding = 0, rgba8) uniform image2D inOutColorImage;
layout(set = 1, binding = 2) buffer correctedDepth
{
    float depth[];
};

layout(push_constant) uniform PC {
   layout(offset = 0) ivec2 screenSize;
   layout(offset = 8) float strength;
   layout(offset = 12) float threshold;
} pc;

float fetchDepth(ivec2 coord)
{
    ivec2 clamped = clamp(coord, ivec2(0), pc.screenSize - ivec2(1));
    uint idx = uint(clamped.x + clamped.y * pc.screenSize.x);
    return depth[idx];
}

void main()
{
    ivec2 gid = ivec2(gl_GlobalInvocationID.xy);
    if (gid.x >= pc.screenSize.x || gid.y >= pc.screenSize.y)
        return;

    uint idx = uint(gid.x + gid.y * pc.screenSize.x);
    vec4 color = imageLoad(inOutColorImage, gid);
    float centerDepth = depth[idx];

    // Skip empty pixels
    if (centerDepth <= 0.0f)
    {
        imageStore(inOutColorImage, gid, color);
        return;
    }

    float gx = fetchDepth(gid + ivec2(1, 0)) - fetchDepth(gid + ivec2(-1, 0));
    float gy = fetchDepth(gid + ivec2(0, 1)) - fetchDepth(gid + ivec2(0, -1));

    float gradient = max(abs(gx), abs(gy));
    float relativeGradient = gradient / max(abs(centerDepth), 1e-3);
    float edge = smoothstep(pc.threshold, pc.threshold * 4.0, relativeGradient);

    float shading = 1.0 - clamp(pc.strength, 0.0, 1.0) * edge;
    imageStore(inOutColorImage, gid, vec4(color.rgb * shading, color.a));
}

#version 450
layout (local_size_x = 16, local_size_y = 16) in;

layout(set = 0, binding = 0, rgba16) uniform image2D inOutColorImage;

layout(push_constant) uniform PC {
   layout(offset = 0) float transparency;
   layout(offset = 4) int substractiveMode;
   layout(offset = 8) ivec2 screenSize;
   layout(offset = 16) vec3 background;
   layout(offset = 28) int noFlash;
   layout(offset = 32) float exposure;
   layout(offset = 36) int compressionMode; // 0 = Reinhard, 1 = Exponential
} pc;

void main() 
{
   if (gl_GlobalInvocationID.x >= pc.screenSize.x ||
       gl_GlobalInvocationID.y >= pc.screenSize.y)
      return;

   vec4 inColor = imageLoad(inOutColorImage, ivec2(gl_GlobalInvocationID.xy));
   float n = inColor.a;
   float a = 1.f - pow(pc.transparency, n);
   vec3 c_rgb = n > 0.f ? inColor.rgb / n : vec3(0.0, 0.0, 0.0);

   // Highlight compression in linear space
   if (pc.noFlash != 0)
   {
      const float knee = 0.6;
      float exposure = max(pc.exposure, 0.0);

      float Y = dot(c_rgb, vec3(0.2126, 0.7152, 0.0722));
      if (Y > 0.0)
      {
         float over = max(Y - knee, 0.0);
         float Yt;
         if (over > 0.0)
         {
            float overTone = (pc.compressionMode == 0)
               ? (over * exposure) / (1.0 + over * exposure)
               : 1.0 - exp(-exposure * over);
            Yt = knee + overTone;
         }
         else
         {
            Yt = Y;
         }

         float scale = Yt / max(Y, 1e-6);
         c_rgb = clamp(c_rgb * scale, vec3(0.0), vec3(1.0));
      }
   }
   // ***** Inversion des couleurs *****
   if (pc.substractiveMode == 1)
      c_rgb = vec3(1.0) - c_rgb;

   vec4 outColor = vec4(mix(pc.background, c_rgb, a), a);

   imageStore(inOutColorImage, ivec2(gl_GlobalInvocationID.xy), outColor);
}

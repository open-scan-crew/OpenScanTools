#version 450
#extension GL_GOOGLE_include_directive : enable
#include "../blocks/block_hsv_functions.glsl"

layout (local_size_x = 16, local_size_y = 16) in;

layout(set = 0, binding = 0, rgba16) uniform image2D inOutColorImage;

layout(push_constant) uniform PC {
   layout(offset = 0) float transparency;
   layout(offset = 4) int substractiveMode;
   layout(offset = 8) ivec2 screenSize;
   layout(offset = 16) vec3 background;
   layout(offset = 28) int noFlash;
   layout(offset = 32) int flashAdvanced;
   layout(offset = 36) float flashControl; // slider value [0..100]
} pc;

void main() 
{
   if (gl_GlobalInvocationID.x >= pc.screenSize.x ||
       gl_GlobalInvocationID.y >= pc.screenSize.y)
      return;

   vec4 inColor = imageLoad(inOutColorImage, ivec2(gl_GlobalInvocationID.xy));
   float n = inColor.a;
   float a = 1.f - pow(pc.transparency, n);
   vec3 c_rgb = n > 0.f ? inColor.rgb / n : vec3(0.0, 0.0, 0.0);

   // Traitement HDR
   if (pc.noFlash != 0)
   {
      if (pc.flashAdvanced == 0)
      {
         // Basic mode: legacy behaviour
         float S = 0.5f;  // seuil
         vec3 c_hsl = rgb2hsl(c_rgb);
         if (a > S)
         {
            c_hsl.z = mix(c_hsl.z, 1.f, (a - S) / (1.0 - S));
            a = 1.0;
         }
         else
         {
            a = a / S;
         }
         c_rgb = hsl2rgb(c_hsl);
      }
      else
      {
         // Advanced mode: tone-map luminance only and preserve chroma
         // Map slider [0..100] to exposure in [0.2, 10.0]
         float exposure = 0.2 + clamp(pc.flashControl, 0.0, 100.0) * (10.0 - 0.2) / 100.0;
         const vec3 luma = vec3(0.2126, 0.7152, 0.0722);
         float Y = dot(c_rgb, luma);
         // Knee to keep mid-tones intact
         float Y0 = 0.6;
         float high = max(Y - Y0, 0.0);
         float Yt = Y0 + (1.0 - exp(-exposure * high));
         float scale = (Y > 1e-6) ? (Yt / Y) : 1.0;
         c_rgb *= scale;
      }
   }
   // ***** Inversion des couleurs *****
   if (pc.substractiveMode == 1)
      c_rgb = vec3(1.0) - c_rgb;

   vec4 outColor = vec4(mix(pc.background, c_rgb, a), a);

   imageStore(inOutColorImage, ivec2(gl_GlobalInvocationID.xy), outColor);
}
